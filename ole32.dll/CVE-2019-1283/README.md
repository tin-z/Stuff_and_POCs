## CVE-2019-1283 
> Jan 11 2020, Altin Thartori, github.com/tin-z

In this write-up i will show how i was able to found a bug in windows, ending in a duplicate case.


###  The Little Bitmap That Could(n’t) - blog post

The author of this [blog](https://www.zerodayinitiative.com/blog/2019/10/31/the-little-bitmap-that-couldnt) describes how he was able to find a security vulnerability by using winafl, and how it ends up Microsoft said that both bugs didn’t meet the bar for servicing and so his report were closed.

The author, not explicitly, describes how to reproduce the environment to start fuzzing with winafl, and so i did.

</br>

### Setup

To build our environment to perform fuzzing, we need the following tools:
  - [DynamoRIO](https://github.com/DynamoRIO/dynamorio)
  - [winafl](https://github.com/googleprojectzero/winafl)

</br>

#### DynamoRIO
In brief, DynamoRIO is a big library, not a framework, that permits us to instrument a binary at runtime, in other words, as the repository says, 
DynamoRIO is a runtime code manipulation system that supports code transformations on any part of a program, while it execute.

We can extend it, in fact, it exports an interface for building dynamic tools for a wide variety of uses, in our case, we are interested in:
  - The instruction counting tool [inscount](https://github.com/DynamoRIO/dynamorio/blob/master/api/samples/inscount.cpp)

We can learn more about it, just by reading this [slide](https://github.com/DynamoRIO/dynamorio/releases/download/release_7_0_0_rc1/DynamoRIO-tutorial-feb2017.pdf), that describes either the use cases and the DynamoRIO System Overview, this last part is realy interesting, all the basic block cache, trace building, etcetera, (probabily it's time that I should buy the [Dragon Book](https://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811)).


Then we can start to collects code coverage information:
  ```
    drrun -t drcov -- <app>
  ```


#### LightHouse
I found either an amazing plugin for Ida Pro, [lighthouse](https://github.com/gaasedelen/lighthouse), that permits us to visualize the Control flow executed (CFE) by extracting the code coverage previously collected with DynamRIO.


#### WinAfl
 [winafl](https://github.com/googleprojectzero/winafl) is a fork of AFL for fuzzing Windows binaries.

All we need to know, for now, is that, instead of instrumenting the code at compilation time, WinAFL supports the following instrumentation modes:

    - Dynamic instrumentation using DynamoRIO (http://dynamorio.org/)
    - Hardware tracing using Intel PT
    - Static instrumentation via Syzygy


#### AFL
Before going further we need to learn more about [AFL](https://github.com/google/AFL), I already meet that requirement, (oh lucky me), but in case you haven't just read these docs:

  - [QuickStartGuide.txt](https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt) -suggested
  - [historical-notes.txt](https://github.com/google/AFL/blob/master/docs/historical_notes.txt)
  - [technical-details.txt](https://github.com/google/AFL/blob/master/docs/technical_details.txt)
  - [life-pro-tips.txt](https://github.com/google/AFL/blob/master/docs/life_pro_tips.txt) -optional
  - [notes-for-asan.txt](https://github.com/google/AFL/blob/master/docs/notes_for_asan.txt) -optional


### Start

After the env is ready you should create an harness file, that'll be the entry point where fuzzers will start the execution.

In my case I did fuzzing the function 'OleLoadPicturePath', more [here](https://docs.microsoft.com/en-us/windows/win32/api/olectl/nf-olectl-oleloadpicturepath), that it is in ole32.dll.

This is the entry-point I did [ConsoleApplication1.cpp](./ConsoleApplication1.cpp), then I compiled it with Visual Studio 2017 CE.

Then, the command to launch should look like this:
```
afl-fuzz.exe -i c:\temp\path_input -o c:\temp\path_output -D c:\winafl-master\DynamoRIO-Windows-7.1.0-1\bin32\ -t 20000 -- -coverage_module oleaut32.dll -target_module ConsoleApplication1.exe -target_method wmain -nargs 2 -- C:\winafl-master\ConsoleApplication1.exe @@
```

```
Parameter         Description
 -i                Location of seed files
 -o                Location of output files
 -D                Path to DynamoRio
 -t                Time in milliseconds (maximum time before killing a process that is pending)
 -coverage_module  Module to record coverage for
 -target_module    The harness we’ve created
 -target_method    Method inside target module we’re targeting
 -nargs            Number of arguments
 --                Executable with @@ to represent params
```

</br>

By first I didn't find nothing, so then I realized that I must give it better input, and I downloaded these [samples](https://www.fileformat.info/format/bmp/sample/index.htm) and selecting also the files with less then 1MB.

After less then an hour I have got some crashes, (oh lucky me, no this time I'm not hironic), now we must report it to Microsoft, we can look these [FAQs](https://www.microsoft.com/en-us/msrc/faqs-report-an-issue).

Before report it to Microsoft, we must understand a little more about the crash, in my case i have a [OOB Read](https://cwe.mitre.org/data/definitions/125.html), and so this is what we can do:
  1. minimize the test-case by using afl-tmin ([minimized](./minimized))
  2. memory dump, dynamic analysis ([minidump](./minidump.zip), [bugidOutput](./bugidOutput.zip))
  3. reverse engineering the crash,code,library (lot of codes not documented here)
  4. POC


Here we can find some AFL/WinAFL Tips and Tricks [here](https://blog.fadyothman.com/afl-tips-tricks/).

We can get a memory dump by using windbg: ``` > .dump /mfh minidump.dmp ```

We can get more info about a crash by using [BugId](https://github.com/SkyLined/BugId)


In the end, my report has been addressed with CVE-2019-1283, and so the case closed as duplicate case.
